%Loop:Models
%FileOverwrite:Models\I=<$>Repository.cs
%Log:IRepository =<$>
/*
**             ------ IMPORTANT ------
** This file was generated by ZeroCode2 on =<DateStamp>
** DO NOT MODIFY IT, as it can be regenerated at any moment.
** If you need this file changed, change the underlying model or its template.
*/
namespace =<#Parameters.msNameSpace>=<Microservice.Namespace>api.Models
{
    public interface I=<$>Repository : IRepository<=<$>DTO, =<$>>
    {
    }
}
%/File

%FileOverwrite:Models\=<$>Repository.cs
%Log:Repository =<$>
/*
**             ------ IMPORTANT ------
** This file was generated by ZeroCode2 on =<DateStamp>
** DO NOT MODIFY IT, as it can be regenerated at any moment.
** If you need this file changed, change the underlying model or its template.
*/
using APIUtils.APIMessaging;
using Microsoft.EntityFrameworkCore;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace =<#Parameters.msNameSpace>=<Microservice.Namespace>api.Models
{

    public class =<$>Repository : I=<$>Repository
    {
        =<Microservice.$>DbContext Context { get; set; }

        public =<$>Repository(=<Microservice.$>DbContext context)
        {
            Context = context;

        }
        public IQueryable<=<$>> List => Context.=<SetName>;

        public async Task<=<$>DTO> Post(SaveMessage<=<$>DTO> rec)
        {
            // TODO: add validations
            // TODO: check for new users to create in the team composition list

            =<$> record = Transformers.Transform(rec.DataSubject, new =<$>()) as =<$>;

%Loop:Children
%If:!Lazy
            record.=<SetName>.ForEach(pi =>
            {
                pi.=<Models.$> = record;
            });
%EndIf
%/Loop:Children

//            record.AccountInfo = Context.AccountInfo.FirstOrDefault();

//            record.ParentContract = Context.Contracts.Find(rec.DataSubject.ParentContractID);

            Context.=<SetName>.Add(record);

            await Context.SaveChangesAsync();

            return Transformers.Transform(record, new =<$>DTO());
        }

        public async Task<=<$>DTO> Put(SaveMessage<=<$>DTO> rec)
        {
            var ctr = await Context.=<SetName>.Where(c => c.ID == rec.ID)
%Loop:Children
                .Include("=<SetName>")
%/Loop:Children
                .FirstOrDefaultAsync();

            if (ctr == null)
            {
                return null;
            }

            ctr = Transformers.Transform(rec.DataSubject, ctr);

            await Context.SaveChangesAsync();

            return Transformers.Transform(ctr, new =<$>DTO());
        }

        public async Task<bool> Delete(SaveMessage<=<$>DTO> rec)
        {
            var ctr = Context.=<SetName>.FirstOrDefault(c => c.ID == rec.ID);

            if (ctr == null)
            {
                return false;
            }

            Context.=<SetName>.Remove(ctr);

            await Context.SaveChangesAsync();

            return true;
        }

        public async Task<=<$>DTO> Get(int id)
        {
            var record = await Context.=<SetName>.Where(c => c.ID == id)
%Loop:Children
                .Include("=<SetName>")
%/Loop:Children
                .FirstOrDefaultAsync();

            var ctr = Transformers.Transform(record, new =<$>DTO() { Modifier = "Unchanged" });

            return ctr;
        }
%Loop:Properties
%If:Reference?=true

        public async List<ListValue> Get=<$>Reference()
        {
%If:ReferenceDBContext?
        // need to correctly create another context
        var ct = new =<ReferenceDBContext>(this.context)
%Else
        var ct = context;
%EndIf
        var records = context.=<ReferenceTable>;
%If:ReferenceFilter?
        records.Where(r => r.(=<ReferenceWhere));
%EndIf
                return await records.Select( s => new ListValue() { Value = s.=<ReferenceID>, Title = s.=<ReferenceTitle>}).ToListAsync();
        }

%EndIf
%/Loop:Properties

%Loop:Children
%Loop:Properties
%If:Reference?=true

        public async List<ListValue> Get=<$>Reference()
        {
%If:ReferenceDBContext?
        // need to correctly create another context
        var ct = new =<ReferenceDBContext>(this.context)
%Else
        var ct = context;
%EndIf
        var records = context.=<ReferenceTable>;
%If:ReferenceFilter?
        records.Where(r => r.(=<ReferenceWhere));
%EndIf
                return await records.Select( s => new ListValue() { Value = s.=<ReferenceID>, Title = s.=<ReferenceTitle>}).ToListAsync();
        }

%EndIf
%/Loop:Properties
%/Loop:Children
    }
}
%/File

%FileOverwrite:Models\=<$>.cs
%Log:Model =<$>
/*
**             ------ IMPORTANT ------
** This file was generated by ZeroCode2 on =<DateStamp>
** DO NOT MODIFY IT, as it can be regenerated at any moment.
** If you need this file changed, change the underlying model or its template.
*/
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Threading.Tasks;
using APIUtils.APIMessaging;

namespace =<#Parameters.msNameSpace>=<Microservice.Namespace>api.Models
{

    public class =<$> 
    {
%Loop:Properties
%If:Values?
        public static ListValue[] =<$>Values =
        {
%Loop:Values
            new ListValue() { Value = "=<$>", Label = "=<[$]>" } %If:HasMore , %EndIf
            
%/Loop:Values
        };
%EndIf
%/Loop:Properties


%Loop:Properties
%If:Key?
        [Key]
%EndIf
%If:Nullable=false
        [Required]
%EndIf
%If:Length?!=unlimited
        [StringLength(=<Length>)]
%EndIf
%If:Format?
        [DisplayFormat(DataFormatString = "{0:=<Format>}")]
%EndIf
        public =<Type> =<$> { get; set; } %If:Default? = =<Default>; %EndIf

%/Loop:Properties

        // Default model properties
        [DisplayFormat(DataFormatString = "{0:dd/MMM/yyyy}")]
        public DateTime CreatedOn { get; set; } = DateTime.Now;

        public string CreatedBy { get; set; }

        [DisplayFormat(DataFormatString = "{0:dd/MMM/yyyy}")]
        public DateTime UpdatedOn { get; set; } = DateTime.Now;

        public string UpdatedBy { get; set; }

%Loop:Children
        public %If:Lazy? virtual %EndIf List<=<$>> =<SetName> { get; private set; } = new List<=<$>>();
%/Loop:Children

    }
}

%/File

%Loop:Children
%If:!Lazy?=true

%Log:Model =<$>
%FileOverwrite:Models\=<$>.cs
/*
**             ------ IMPORTANT ------
** This file was generated by ZeroCode2 on =<DateStamp>
** DO NOT MODIFY IT, as it can be regenerated at any moment.
** If you need this file changed, change the underlying model or its template.
*/
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Threading.Tasks;
using APIUtils.APIMessaging;

namespace =<#Parameters.msNameSpace>=<Microservice.Namespace>api.Models
{

    public class =<$> 
    {
%Loop:Properties
%If:Values?
        public static ListValue[] =<$>Values =
        {
%Loop:Values
            new ListValue() { Value = "=<$>", Label = "=<[$]>" } %If:HasMore , %EndIf

%/Loop:Values
        };
%EndIf
%/Loop:Properties

%Loop:Properties
%If:Type?
%If:Key?
        [Key]
%EndIf
%If:Nullable=false
        [Required]
%EndIf
%If:Length?!=unlimited
        [StringLength(=<Length>)]
%EndIf
%If:Format?
        [DisplayFormat(DataFormatString = "{0:=<Format>}")]
%EndIf
        public =<Type> =<$> { get; set; } %If:Default? = =<Default>; %EndIf

%EndIf
%/Loop:Properties

        // Parent property
        public =<Models.$> =<Models.$> { get; set; } 

        // Default model properties
        [DisplayFormat(DataFormatString = "{0:dd/MMM/yyyy}")]
        public DateTime CreatedOn { get; set; } = DateTime.Now;

        public string CreatedBy { get; set; }

        [DisplayFormat(DataFormatString = "{0:dd/MMM/yyyy}")]
        public DateTime UpdatedOn { get; set; } = DateTime.Now;

        public string UpdatedBy { get; set; }

    }
}
%/File
%EndIf
%/Loop:Children

%FileOverwrite:Models\=<$>DTO.cs
%Log:DTO =<$>
/*
**             ------ IMPORTANT ------
** This file was generated by ZeroCode2 on =<DateStamp>
** DO NOT MODIFY IT, as it can be regenerated at any moment.
** If you need this file changed, change the underlying model or its template.
*/
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Threading.Tasks;

namespace =<#Parameters.msNameSpace>=<Microservice.Namespace>api.Models
{


    public class =<$>DTO : DTOBase
    {
%Loop:Properties
%If:Key?
        [Key]
%EndIf
%If:Nullable=false
        [Required]
%EndIf
%If:Length?!=unlimited
        [StringLength(=<Length>)]
%EndIf
%If:Format?
        [DisplayFormat(DataFormatString = "{0:=<Format>}")]
%EndIf
        [JsonProperty(PropertyName = "=<JSONName>")]
        public =<Type> =<$> { get; set; } %If:Default? = =<Default>; %EndIf

%If:Lookup?=true
        [JsonProperty(PropertyName = "=<JSONName>Label")]
        public =<Type> =<$>Label { get; set; }
%EndIf

%/Loop:Properties

        // Default model properties
        [DisplayFormat(DataFormatString = "{0:dd/MMM/yyyy}")]
        public DateTime CreatedOn { get; set; } = DateTime.Now;

        public string CreatedBy { get; set; }

        [DisplayFormat(DataFormatString = "{0:dd/MMM/yyyy}")]
        public DateTime UpdatedOn { get; set; } = DateTime.Now;

        public string UpdatedBy { get; set; }

%Loop:Children
        [JsonProperty(PropertyName = "=<SetName>")]
        public %If:Lazy? virtual %EndIf List<=<$>DTO> =<SetName> { get; private set; } = new List<=<$>DTO>();
%/Loop:Children

    }
}

%/File

%Loop:Children
%If:!Lazy?=true
%Log:DTO =<$>
%FileOverwrite:Models\=<$>DTO.cs
/*
**             ------ IMPORTANT ------
** This file was generated by ZeroCode2 on =<DateStamp>
** DO NOT MODIFY IT, as it can be regenerated at any moment.
** If you need this file changed, change the underlying model or its template.
*/
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Threading.Tasks;

namespace =<#Parameters.msNameSpace>=<Microservice.Namespace>api.Models
{


    public class =<$>DTO : DTOBase
    {
%Loop:Properties
%If:Type?
%If:Key?
        [Key]
%EndIf
%If:Nullable=false
        [Required]
%EndIf
%If:Length?!=unlimited
        [StringLength(=<Length>)]
%EndIf
%If:Format?
        [DisplayFormat(DataFormatString = "{0:=<Format>}")]
%EndIf
        [JsonProperty(PropertyName = "=<JSONName>")]
        public =<Type> =<$> { get; set; } %If:Default? = =<Default>; %EndIf

%If:Lookup?=true
        [JsonProperty(PropertyName = "=<JSONName>Label")]
        public =<Type> =<$>Label { get; set; }
%EndIf

%EndIf
%/Loop:Properties

        // Parent property
        public =<Models.$> =<Models.$>DTO {get; set; } 

        // Default model properties
        [DisplayFormat(DataFormatString = "{0:dd/MMM/yyyy}")]
        public DateTime CreatedOn { get; set; } = DateTime.Now;

        public string CreatedBy { get; set; }

        [DisplayFormat(DataFormatString = "{0:dd/MMM/yyyy}")]
        public DateTime UpdatedOn { get; set; } = DateTime.Now;

        public string UpdatedBy { get; set; }

    }
}
%/File
%EndIf
%/Loop:Children

%/Loop:Models

%Log:Transformers
%FileOverwrite:Models\Transformers.cs
/*
**             ------ IMPORTANT ------
** This file was generated by ZeroCode2 on =<DateStamp>
** DO NOT MODIFY IT, as it can be regenerated at any moment.
** If you need this file changed, change the underlying model or its template.
*/
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace =<#Parameters.msNameSpace>=<Microservice.Namespace>api.Models
{

    public class Transformers
    {

%Loop:Models
        public static =<$> Transform(=<$>DTO from, =<$> to)
        {
%Loop:Properties
                to.=<$> = from.=<$>;
%/Loop:Properties

            // here we need to do some magic with the modifiers of the DTO collection:
%Loop:Children
%If:!Lazy
            TransformList<=<$>DTO, =<$>>(from.=<SetName>, to.=<SetName>, 
                (list, from) => list.Find(pt => pt.ID == from.ID),
                Transform);

%EndIf
%/Loop:Children
            return to;
        }

        public static =<$>DTO Transform(=<$> from, =<$>DTO to)
        {
%Loop:Properties
                to.=<$> = from.=<$>;
%If:Lookup?=true
                to.=<$>Label = =<Models.$>.=<$>Values.FirstOrDefault( v => v.Value.Equals(from.=<$>))?.Label;
%EndIf
%/Loop:Properties

%Loop:Children
%If:!Lazy
            to.=<SetName>.AddRange(from.=<SetName>.Select(p => Transform(p, new =<$>DTO() { Modifier = "Unchanged" })));
%EndIf
%/Loop:Children

            return to;
        }

%Loop:Children
%If:!Lazy
        public static =<$> Transform(=<$>DTO from, =<$> to)
        {
%Loop:Properties
            to.=<$> = from.=<$>;
%/Loop:Properties

            return to;
        }

        public static =<$>DTO Transform(=<$> from, =<$>DTO to)
        {
%Loop:Properties
            to.=<$> = from.=<$>;
%If:Lookup?=true
            to.=<$>Label = =<Children.$>.=<$>Values.FirstOrDefault( v => v.Value.Equals(from.=<$>))?.Label;
%EndIf
%/Loop:Properties

            return to;
        }

%EndIf
%/Loop:Children

%/Loop:Models

        private static void TransformList<F, T>(List<F> from, List<T> to, Func<List<T>, F, T> find, Func<F, T, T> transform) where F : DTOBase where T : class, new()
        {
            foreach (F p in from)
            {
                if (p.Modifier == "Deleted")
                {
                    if (find(to, p) is T toDelete)
                    {
                        to.Remove(toDelete);
                    }
                }
                if (p.Modifier == "Added")
                {
                    var toAdd = transform(p, new T());
                    to.Add(toAdd);
                }
                if (p.Modifier == "Modified")
                {
                    if (find(to, p) is T toUpdate)
                    {
                        _ = transform(p, toUpdate);
                    }
                }
            }
        }
    }
}

%/File

