%Loop:Models
%FileOverwrite:Models\I=<$>Repository.cs
%Log:IRepository =<$>
/*
**             ------ IMPORTANT ------
** This file was generated by ZeroCode2 on =<DateStamp>
** DO NOT MODIFY IT, as it can be regenerated at any moment.
** If you need this file changed, change the underlying model or its template.
*/
using APIUtils.APIMessaging;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace =<#Parameters.msNameSpace>=<Microservice.Namespace>api.Models
{
    public interface I=<$>Repository : IRepository<=<$>>
    {
%Loop:Properties
%If:Reference?=true
        public Task<List<ListValue>> Get=<$>Reference();
%EndIf
%/Loop:Properties

%Loop:Children
%Loop:Properties
%If:Reference?=true
        public Task<List<ListValue>> Get=<$>Reference();
%EndIf
%/Loop:Properties
%/Loop:Children
    }
}
%/File

%FileOverwrite:Models\=<$>Repository.cs
%Log:Repository =<$>
/*
**             ------ IMPORTANT ------
** This file was generated by ZeroCode2 on =<DateStamp>
** DO NOT MODIFY IT, as it can be regenerated at any moment.
** If you need this file changed, change the underlying model or its template.
*/
using APIUtils.APIMessaging;
using Microsoft.EntityFrameworkCore;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Linq.Dynamic.Core;

namespace =<#Parameters.msNameSpace>=<Microservice.Namespace>api.Models
{

    public class =<$>Repository : I=<$>Repository
    {
        =<Microservice.$>DbContext Context { get; set; }

        public =<$>Repository(=<Microservice.$>DbContext context)
        {
            Context = context;

        }
        public IQueryable<=<$>> List => Context.=<SetName>
%Loop:Properties
%If:Reference?=true
                .Include(p => p.=<ReferenceObjectName>)
%EndIf
%/Loop:Properties
        ;

        public async Task<(List<=<$>>, double)> FilteredAndSortedList(SortAndFilterInformation sortAndFilterInfo, bool paging)
        {
            return await DoSortFilterAndPaging(sortAndFilterInfo, paging);
        }

        private async Task<(List<=<$>>, double)> DoSortFilterAndPaging(SortAndFilterInformation sentModel, bool doPaging)
        {
            string whereClause = String.Empty;
            var records = List;
            int filteredCount = records.Count();

            if (sentModel != null)
            {
                string[] strings = {
%Loop:Properties
%If:Type=string
                        "=<JSONName>",
%EndIf
%/Loop
                        ""
                };
                // filtering
                // column search is handled here:0
                if (sentModel.filtered != null)
                {
                    foreach (var item in sentModel.filtered)
                    {
                        if (!String.IsNullOrEmpty(item.value))
                        {
                                if(strings.Contains(item.id))
                                {
                                    whereClause = whereClause + item.id + ".Contains(\"" + item.value + "\") &&";
                                } else {
                                    whereClause = whereClause + item.id + ".ToString().Contains(\"" + item.value + "\") &&";
                                }
                        }
                    }
                    if (!string.IsNullOrEmpty(whereClause))
                    {
                        whereClause = whereClause[0..^2];
                        records = records.Where(whereClause);
                        filteredCount = await records.CountAsync();
                    }
                }
                // ordering
                if (sentModel.sorted != null)
                {
                    string orderBy = "";
                    foreach (var o in sentModel.sorted)
                    {
                        orderBy += " " + o.id + (o.desc ? " DESC" : " ASC") + ",";
                    }
                    if (orderBy.EndsWith(','))
                    {
                        orderBy = orderBy[0..^1];
                    }
                    if (!string.IsNullOrEmpty(orderBy))
                    {
                        records = records.OrderBy(orderBy);
                    }
                }

                // paging:
                if (doPaging)
                {
                    records = records
                        .Skip(sentModel.page * sentModel.pageSize)
                        .Take(sentModel.pageSize);
                }
            }
            return (await records.ToListAsync(), sentModel?.pageSize != 0 ? Math.Ceiling((double)(filteredCount / sentModel.pageSize)) : 1.0);
        }


        public async Task<=<$>> Post(=<$> rec)
        {
            var record = rec;
            // TODO: add validations
            // TODO: check for new users to create in the team composition list
%Loop:Children
%If:!Lazy
            record.=<SetName>.ForEach(pi =>
            {
                pi.=<Models.$> = record;
            });
%EndIf
%/Loop:Children

//            record.AccountInfo = Context.AccountInfo.FirstOrDefault();

//            record.ParentContract = Context.Contracts.Find(rec.DataSubject.ParentContractID);

            Context.=<SetName>.Add(record);

            await Context.SaveChangesAsync();

            return record;
        }

        public async Task<=<$>> Put(=<$> rec)
        {
            Context.=<SetName>.Attach(rec);

            await Context.SaveChangesAsync();

            return rec;
        }

        public async Task<bool> Delete(=<$> rec)
        {
            var ctr = Context.=<SetName>.FirstOrDefault(c => c.ID == rec.ID);

            if (ctr == null)
            {
                return false;
            }

            Context.=<SetName>.Remove(ctr);

            await Context.SaveChangesAsync();

            return true;
        }

        public async Task<=<$>> Get(int id)
        {
            var record = await Context.=<SetName>.Where(c => c.ID == id)
%Loop:Children
                .Include( p => p.=<SetName>)
%/Loop:Children
%Loop:Properties
%If:Reference?=true
                .Include(p => p.=<ReferenceObjectName>)
%EndIf
%/Loop:Properties
                .FirstOrDefaultAsync();
            return record;
        }
%Loop:Properties
%If:Reference?=true

        public async Task<List<ListValue>> Get=<$>Reference()
        {
%If:ReferenceDBContext?
        // need to correctly create another context
        var ct = new =<ReferenceDBContext>(this.context)
%Else
        var ct = Context;
%EndIf
        var records = ct.=<ReferenceSet>;
%If:ReferenceFilter?
        records.Where(r => r.(=<ReferenceWhere));
%EndIf
        return await records.Select( s => new ListValue() { Value = s.=<ReferenceID>, Label = s.=<ReferenceTitle>}).ToListAsync();
}

%EndIf
%/Loop:Properties

%Loop:Children
%Loop:Properties
%If:Reference?=true

        public async Task<List<ListValue>> Get=<$>Reference()
        {
%If:ReferenceDBContext?
        // need to correctly create another context
        var ct = new =<ReferenceDBContext>(this.context)
%Else
        var ct = Context;
%EndIf
        var records = ct.=<ReferenceSet>;
%If:ReferenceFilter?
        records.Where(r => r.(=<ReferenceWhere));
%EndIf
        return await records.Select( s => new ListValue() { Value = s.=<ReferenceID>, Label = s.=<ReferenceTitle>}).ToListAsync();
}

%EndIf
%/Loop:Properties
%/Loop:Children
    }
}
%/File

%FileOverwrite:Models\=<$>.cs
%Log:Model =<$>
/*
**             ------ IMPORTANT ------
** This file was generated by ZeroCode2 on =<DateStamp>
** DO NOT MODIFY IT, as it can be regenerated at any moment.
** If you need this file changed, change the underlying model or its template.
*/
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Threading.Tasks;
using APIUtils.APIMessaging;

namespace =<#Parameters.msNameSpace>=<Microservice.Namespace>api.Models
{

    public class =<$>
    {
%Loop:Properties
%If:Values?
        public static ListValue[] =<$>Values =
        {
%Loop:Values
            new ListValue() { Value = "=<$>", Label = "=<[$]>" } %If:HasMore , %EndIf

%/Loop:Values
        };
%EndIf
%/Loop:Properties


%Loop:Properties
%If:Key?
        [Key]
%EndIf
%If:Nullable=false
        [Required]
%EndIf
%If:Length?!=unlimited
        [StringLength(=<Length>)]
%EndIf
%If:Format?
        [DisplayFormat(DataFormatString = "{0:=<Format>}")]
%EndIf
        public =<Type> =<$> { get; set; } %If:Default? = =<Default>; %EndIf

%If:Reference?=true
        public =<ReferenceType> =<ReferenceObjectName> { get; set; }
%EndIf

%/Loop:Properties

        // Default model properties
        [DisplayFormat(DataFormatString = "{0:dd/MMM/yyyy}")]
        public DateTime CreatedOn { get; set; } = DateTime.Now;

        public string CreatedBy { get; set; }

        [DisplayFormat(DataFormatString = "{0:dd/MMM/yyyy}")]
        public DateTime UpdatedOn { get; set; } = DateTime.Now;

        public string UpdatedBy { get; set; }

%Loop:Children
        public %If:Lazy? virtual %EndIf List<=<$>> =<SetName> { get; private set; } = new List<=<$>>();
%/Loop:Children

    }
}

%/File

%Loop:Children
%If:!Lazy?=true

%Log:Model =<$>
%FileOverwrite:Models\=<$>.cs
/*
**             ------ IMPORTANT ------
** This file was generated by ZeroCode2 on =<DateStamp>
** DO NOT MODIFY IT, as it can be regenerated at any moment.
** If you need this file changed, change the underlying model or its template.
*/
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Threading.Tasks;
using APIUtils.APIMessaging;

namespace =<#Parameters.msNameSpace>=<Microservice.Namespace>api.Models
{

    public class =<$>
    {
%Loop:Properties
%If:Values?
        public static ListValue[] =<$>Values =
        {
%Loop:Values
            new ListValue() { Value = "=<$>", Label = "=<[$]>" } %If:HasMore , %EndIf

%/Loop:Values
        };
%EndIf
%/Loop:Properties

%Loop:Properties
%If:Type?
%If:Key?
        [Key]
%EndIf
%If:Nullable=false
        [Required]
%EndIf
%If:Length?!=unlimited
        [StringLength(=<Length>)]
%EndIf
%If:Format?
        [DisplayFormat(DataFormatString = "{0:=<Format>}")]
%EndIf
        public =<Type> =<$> { get; set; } %If:Default? = =<Default>; %EndIf

%If:Reference?=true
        public =<ReferenceType> =<ReferenceObjectName> { get; set; }
%EndIf        
%Else
%Error:Must specify a type for =<$>
%EndIf
%/Loop:Properties

        // Parent property
        public =<Models.$> =<Models.$> { get; set; }

        // Default model properties
        [DisplayFormat(DataFormatString = "{0:dd/MMM/yyyy}")]
        public DateTime CreatedOn { get; set; } = DateTime.Now;

        public string CreatedBy { get; set; }

        [DisplayFormat(DataFormatString = "{0:dd/MMM/yyyy}")]
        public DateTime UpdatedOn { get; set; } = DateTime.Now;

        public string UpdatedBy { get; set; }

    }
}
%/File
%EndIf
%/Loop:Children

%FileOverwrite:Models\=<$>DTO.cs
%Log:DTO =<$>
/*
**             ------ IMPORTANT ------
** This file was generated by ZeroCode2 on =<DateStamp>
** DO NOT MODIFY IT, as it can be regenerated at any moment.
** If you need this file changed, change the underlying model or its template.
*/
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Threading.Tasks;

namespace =<#Parameters.msNameSpace>=<Microservice.Namespace>api.Models
{


    public class =<$>DTO : DTOBase
    {
%Loop:Properties
%If:Key?
        [Key]
%EndIf
%If:Nullable=false
        [Required]
%EndIf
%If:Length?!=unlimited
        [StringLength(=<Length>)]
%EndIf
%If:Format?
        [DisplayFormat(DataFormatString = "{0:=<Format>}")]
%EndIf
        [JsonProperty(PropertyName = "=<JSONName>")]
        public =<Type> =<$> { get; set; } %If:Default? = =<Default>; %EndIf

%If:Lookup?=true
        [JsonProperty(PropertyName = "=<JSONName>Label")]
        public string =<$>Label { get; set; }
%EndIf

%/Loop:Properties

        // Default model properties
        [DisplayFormat(DataFormatString = "{0:dd/MMM/yyyy}")]
        public DateTime CreatedOn { get; set; } = DateTime.Now;

        public string CreatedBy { get; set; }

        [DisplayFormat(DataFormatString = "{0:dd/MMM/yyyy}")]
        public DateTime UpdatedOn { get; set; } = DateTime.Now;

        public string UpdatedBy { get; set; }

%Loop:Children
        [JsonProperty(PropertyName = "=<SetName>")]
        public %If:Lazy? virtual %EndIf List<=<$>DTO> =<SetName> { get; private set; } = new List<=<$>DTO>();
%/Loop:Children

    }
}

%/File

%Loop:Children
%If:!Lazy?=true
%Log:DTO =<$>
%FileOverwrite:Models\=<$>DTO.cs
/*
**             ------ IMPORTANT ------
** This file was generated by ZeroCode2 on =<DateStamp>
** DO NOT MODIFY IT, as it can be regenerated at any moment.
** If you need this file changed, change the underlying model or its template.
*/
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Threading.Tasks;

namespace =<#Parameters.msNameSpace>=<Microservice.Namespace>api.Models
{


    public class =<$>DTO : DTOBase
    {
%Loop:Properties
%If:Type?
%If:Key?
        [Key]
%EndIf
%If:Nullable=false
        [Required]
%EndIf
%If:Length?!=unlimited
        [StringLength(=<Length>)]
%EndIf
%If:Format?
        [DisplayFormat(DataFormatString = "{0:=<Format>}")]
%EndIf
        [JsonProperty(PropertyName = "=<JSONName>")]
        public =<Type> =<$> { get; set; } %If:Default? = =<Default>; %EndIf

%If:Lookup?=true
        [JsonProperty(PropertyName = "=<JSONName>Label")]
        public string =<$>Label { get; set; }
%EndIf

%EndIf
%/Loop:Properties

        // Parent property
        public =<Models.$> =<Models.$>DTO {get; set; }

        // Default model properties
        [DisplayFormat(DataFormatString = "{0:dd/MMM/yyyy}")]
        public DateTime CreatedOn { get; set; } = DateTime.Now;

        public string CreatedBy { get; set; }

        [DisplayFormat(DataFormatString = "{0:dd/MMM/yyyy}")]
        public DateTime UpdatedOn { get; set; } = DateTime.Now;

        public string UpdatedBy { get; set; }

    }
}
%/File
%EndIf
%/Loop:Children

%/Loop:Models

%Log:Transformers
%FileOverwrite:Models\Transformers.cs
/*
**             ------ IMPORTANT ------
** This file was generated by ZeroCode2 on =<DateStamp>
** DO NOT MODIFY IT, as it can be regenerated at any moment.
** If you need this file changed, change the underlying model or its template.
*/
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace =<#Parameters.msNameSpace>=<Microservice.Namespace>api.Models
{

    public class Transformers
    {

%Loop:Models
        public static =<$> Transform(=<$>DTO from, =<$> to)
        {
%Loop:Properties
%If:Reference?=true
%If:Nullable?=true
                // check if actually filled
                if(from.=<$> != 0) {
                        to.=<$> = from.=<$>;
                }
%Else
                to.=<$> = from.=<$>;
%EndIf
%Else
                to.=<$> = from.=<$>;
%EndIf
%/Loop:Properties

            // here we need to do some magic with the modifiers of the DTO collection:
%Loop:Children
%If:!Lazy
            TransformList<=<$>DTO, =<$>>(from.=<SetName>, to.=<SetName>,
                (list, from) => list.Find(pt => pt.ID == from.ID),
                Transform);

%EndIf
%/Loop:Children
            return to;
        }

        public static =<$>DTO Transform(=<$> from, =<$>DTO to)
        {
%Loop:Properties
                to.=<$> = from.=<$>;
%If:Lookup?=true
%If:Reference?=true
%If:Nullable?=true
                to.=<$>Label = from.=<ReferenceObjectName>?.=<ReferenceTitle>;
%Else
                to.=<$>Label = from.=<ReferenceObjectName>.=<ReferenceTitle>;
%EndIf
%Else
                to.=<$>Label = =<Models.$>.=<$>Values.FirstOrDefault( v => v.Value.Equals(from.=<$>))?.Label;
%EndIf
%EndIf
%/Loop:Properties

%Loop:Children
%If:!Lazy
            to.=<SetName>.AddRange(from.=<SetName>.Select(p => Transform(p, new =<$>DTO() { Modifier = "Unchanged" })));
%EndIf
%/Loop:Children

            return to;
        }

%Loop:Children
%If:!Lazy

        public static =<$> Transform(=<$>DTO from, =<$> to)
        {
%Loop:Properties
%If:Reference?=true
%If:Nullable?=true
                // check if actually filled
                if(from.=<$> != 0) {
                        to.=<$> = from.=<$>;
                }
%Else
                to.=<$> = from.=<$>;
%EndIf
%Else
                to.=<$> = from.=<$>;
%EndIf
%/Loop:Properties

            return to;
        }

        public static =<$>DTO Transform(=<$> from, =<$>DTO to)
        {
%Loop:Properties
            to.=<$> = from.=<$>;
%If:Lookup?=true
%If:Reference?=true
%If:Nullable?=true
                to.=<$>Label = from.=<ReferenceObjectName>?.=<ReferenceTitle>;
%Else
                to.=<$>Label = from.=<ReferenceObjectName>.=<ReferenceTitle>;
%EndIf
%Else
                to.=<$>Label = =<Children.$>.=<$>Values.FirstOrDefault( v => v.Value.Equals(from.=<$>))?.Label;
%EndIf
%EndIf
%/Loop:Properties

            return to;
        }

%EndIf
%/Loop:Children

%/Loop:Models

        private static void TransformList<F, T>(List<F> from, List<T> to, Func<List<T>, F, T> find, Func<F, T, T> transform) where F : DTOBase where T : class, new()
        {
            foreach (F p in from)
            {
                if (p.Modifier == "Deleted")
                {
                    if (find(to, p) is T toDelete)
                    {
                        to.Remove(toDelete);
                    }
                }
                if (p.Modifier == "Added")
                {
                    var toAdd = transform(p, new T());
                    to.Add(toAdd);
                }
                if (p.Modifier == "Modified")
                {
                    if (find(to, p) is T toUpdate)
                    {
                        _ = transform(p, toUpdate);
                    }
                }
            }
        }
    }
}

%/File

