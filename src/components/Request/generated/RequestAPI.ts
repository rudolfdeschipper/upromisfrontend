/*
**             ------ IMPORTANT ------
** This file was generated by ZeroCode2 on 29/Dec/2020 21:56:58
** DO NOT MODIFY IT, as it can be regenerated at any moment.
** If you need this file changed, change the underlying model or its template.
*/

import { ILoadResult, IListInfo, ISaveMessage, IAPIResult, ISelectValueList } from '../../GeneralTypes';
import { http } from '../../http';
import { Utils } from '../../Utils';

import { IRequestData } from './RequestTypes';

export class RequestAPI {

    static webAPIUrl : string = 'http://localhost:5001/api';

    static loadList = async (listInfo: IListInfo, token: string) : Promise<ILoadResult<IRequestData>> => 
    {
        try {
            const result = await http<IListInfo, ILoadResult<IRequestData>>( RequestAPI.webAPIUrl,
                {
                    path: '/request/getlist',
                    method: 'post',
                    body: listInfo,
                    accessToken: token
                }
            );
            if (result.ok && result.parsedBody) {
                return {...result.parsedBody };
            } else {
                return { data: [], pages: 0, message: result.statusText  };
            }
        } catch (ex) {
            console.error(ex);
            return { data: [], pages: 0, message: ex  };
        }

    }


    static loadListForExport = async (title: string, listInfo: IListInfo, token: string)  : Promise<void> => 
    {
        try {
            const result = await http<IListInfo, any>( RequestAPI.webAPIUrl,
                {
                    path: '/request/getforexport',
                    method: 'post',
                    body: { ...listInfo, page: 1},
                    accessToken: token
                }
            )
            result.blob().then(blob => {
                    let url = window.URL.createObjectURL(blob);
                    let a = document.createElement('a');
                    let filename = title + " - " + Utils.formatDate(Date.now()).replace(/\//g, "-") + ".xlsx";
                    a.href = url;
                    a.download = filename;
                    a.click();
                    a.remove();
                });
        } catch (ex) {
            console.error(ex);
        }
    }


    static saveRecord = async (message: ISaveMessage<IRequestData>, token: string): Promise<IAPIResult<IRequestData>> => {

        try {
            const result = await http<ISaveMessage<IRequestData>, IAPIResult<IRequestData>>(
                RequestAPI.webAPIUrl,
                {
                    path: '/request',
                    method: message.action,
                    body: message,
                    accessToken: token
                }
            );
            if (result.ok && result.parsedBody) {
                return {...result.parsedBody, success: true };
            } else {
                return { id: message.id, dataSubject: undefined, success: false,  message: result.statusText };
            }
        } catch (ex) {
            console.error(ex);
            return { id: message.id, dataSubject: undefined, success: false,  message: ex };
        }
    };

    static loadOneRecord = async (id: number, token: string): Promise<IAPIResult<IRequestData>> => {

        try {
            const result = await http<ISaveMessage<IRequestData>, IAPIResult<IRequestData>>(
                RequestAPI.webAPIUrl,
                {
                    path: '/request/' + id,
                    method: 'get',
                    accessToken: token
                }
            );
            if (result.ok && result.parsedBody) {
                return {...result.parsedBody, success: true };
            } else {
                return { id: id, dataSubject: undefined, success: false,  message: result.statusText };
            }
        } catch (ex) {
            console.error(ex);
            return { id: id, dataSubject: undefined, success: false,  message: ex };
        }

    }

    static loadDropdownValues = async (valueType: string, token: string): Promise<ISelectValueList> => {

        try {
            const result = await http<any, ISelectValueList>(
                RequestAPI.webAPIUrl,
                {
                    path: '/request/getselectvalues',
                    method: 'post',
                    body: {valueType: valueType},
                    accessToken: token
                }
            );
            if (result.ok && result.parsedBody) {
                return {...result.parsedBody };
            } else {
                return { data: [], valueType: valueType };
            }
        } catch (ex) {
            console.error(ex);
            return { data: [], valueType: valueType };
        }
    }

}

